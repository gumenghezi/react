<!DOCTYPE html>
<html lang="en">

<head>
 <meta charset="UTF-8">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Document</title>
</head>

<body>
 <!-- 
 1. 类中的构造器不是必须要写的,如果想给实例添加一些独有的属性,就要写构造器。
 2. 如果A类继承了B类,在A类中写了构造器,那么在A类的构造器中必须调用super
 3. 类中的方法是放在类的原型对象上的,供实例使用。如果是通过实例调用的方法,那么方法中的this就是实例对象
 -->


 <!-- 
  1. super 关键字
  -->
</body>
<script>
 class Person {
  // 构造方法
  constructor(name, age) {
   // 构造器中的this是谁? 当前实例对象
   this.name = name;
   this.age = age;
   this.grade = 2
  }

  // 一般方法
  /*
    1.speak放在了哪里? ---- Person的原型对象上，供实例使用
    2.spank中的this是谁? ---- 如果speak是通过Person实例调用的,this就是实例对象 
  */
  speak() {

  }
 }
 /*
  3. super 关键字
     第一种: 当函数使用,代表父类的构造函数
     第二种: 当对象使用,指向父类的原型对象,定义在父类实例上的方法或属性，是无法通过super调用的
     super在静态方法中指向父类,父类内部的实例指向子类
     在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。
 */

 // 当函数使用
 class Student1 extends Person {
  // 给实例添加一些独有的属性
  constructor() {
   // 代表调用了父类的构造函数,
   // Person.prototype.constructor.call(this)
   super()
  }
 }

 // 当对象使用
 class Student2 extends Person {
  // 给实例添加一些独有的属性
  constructor() {
   super();
   console.log(super.grade) // undefined
  }
 }

 let s1 = new Student2()
</script>

</html>